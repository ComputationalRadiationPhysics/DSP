#ifndef DATAREADER_HPP
#define DATAREADER_HPP

#include <iostream>
#include <fstream> 
#include <string> 
#include <pthread.h>
#include "../Config/Types.hpp"
#include "../Config/Constants.hpp"
#include "../Utility/Ringbuffer.hpp"

/*! DataReader
 *  @brief Is meant as a producer for the Ringbuffer class. 
 *  It reads data from datafiles as generated by DCDB_Gen.
 *
 *  The DataReader class reads data files generated by Dacqn 
 *  program to acquire signals from semiconductor gamma detectors
 *  or the DCDB_Gen program to generate synthetic data for testing
 *  purposes.
 *  
 *  It separates the signals from two channels into two individual
 *  waveforms. A given number of signals is written to the specified
 *  Ringbuffer in one chunk. If EOF is reached before all signals
 *  for one chunk are read the remaining slots in the chunk are filled
 *  with zeros.
 */

class DataReader {

private:
    std::string inputFilename;
    InputBuffer* rb;
    std::vector<MeasureType> channelBuffer;

    int nSamp;
    int nSeg;
    int nWf;
    int nChunk;

public:
    /**
     * Basic constructor
     *
     * Creates the DataReader for the given filename and connects it
     * to the Ringbuffer buffer. Multiple signals are read and written
     * to the buffer in one chunk.
     *
     * \param filename The file to be read. It needs to follow the
     *                 datastructure as produced by DCDB_Gen.
     * \param buffer The ringbuffer to be filled with the data.
     * \param chunksize Sets the number of signals in one chunk.
     */
    DataReader(const std::string& filename, InputBuffer* buffer,
               int chunksize);
    ~DataReader();

    /** 
     * Read the header of a datafile, i.e. to get the number of samples
     * per signal.
     *
     * Often the number of samples per signal is needed to instanciate
     * other classes. Use this function to get the header data of a 
     * file before instanciating a DataReader
     *
     * \param filename The file to be read.
     * \param nSample The number of samples per signal is written to this
     *                address.
     * \param nSegment The number of data segments in the file is written
     *                 to this address.
     * \param nWaveform The number of signals (waveforms) in the file
     *                  is written to this address.
     */
    static int readHeader(const std::string& filename,
                          int &nSample, int &nSegment, int &nWaveform);

    /** 
     * Start reading data from the file and write it to the buffer.
     *
     * Signals are read from the datafile. The two interleaved signals 
     * of one event as recorded by two channels are separated by the 
     * reader into two individual signals.
     * The sample data is casted from <MeasureType> to <DATATYPE> as 
     * needed for later processing on the devices.
     * A number of chunksize signals are written to the buffer in one
     * chunk after the other.
     * If EOF is reached before a chunk can be filled with signals the
     * remaining space is filled with zeros. That means in the later
     * evaluation there will appear signals with constant amplitude of 
     * zero.
     */
    void readToBuffer();

    /** Return number of samples per signal as given by the header of
     *  the file.
     *  \return Number of samples per signal
     */
    int get_nSamp();

    /** Return number of signals per segment as given by the header of
     *  the file. At the moment only nSeg==1 is supported.
     *  \return Number of signals per segment.
     */
    int get_nSeg();

    /** Return number of signals (waveforms) in the datafile as given
     *  by the header of the file.
     *  \return Number of signals in the datafile.
     */
    int get_nWf();
};

#endif
